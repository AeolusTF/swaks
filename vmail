#!/usr/bin/perl

use strict; # *gasp*!  A program by jetmore that uses strict?!?!

use IO::Socket qw();
use Net::DNS;
use WCS::Util qw();
use Getopt::Std;

my($from, $to, $helo, $data, $server, $port) = (undef);
my(%opt) = ();
my($user) = getpwuid($<);
my($hostname) = get_hostname();

if (!getopts('l:f:t:h:s:p:d:i:q:gm', \%opt)) {
  print STDERR "getopts parsing error\n";
  exit(1);
}
# l - specify location of a file containing a (l)ist of data to be used
# f - specify the (f)rom address
# t - specify the (t)o address
# h - who do I claim to be in the (h)elo transaction?
# s - what (s)erver do I send this mail to?
# p - what (p)ort do I connect to?
# d - what is the (d)ata section of the email?
# i - enter interactive mode
# g - (g)et data on STDIN
# m - emulate basic "Mail -v" functionality
# q - send quit after (valid options are 'helo', 'mail', 'rcpt', and 'connect')

$opt{q} = lc($opt{q}) if ($opt{q});

if ($opt{m}) {
  if ($opt{i} !~ /t/i && !$opt{t}) {
    $to = shift;
  }
  if ($opt{i} !~ /d/i) {
    $opt{i} .= 'd';
  }
}

process_file($opt{l}) if ($opt{l});
$from   = $opt{f} if ($opt{f});
$to     = $opt{t} if ($opt{t});
$helo   = $opt{h} if ($opt{h});
$server = $opt{s} if ($opt{s});
$port   = $opt{p} if ($opt{p});
$data   = $opt{d} if ($opt{d});
process_interact($opt{i}) if ($opt{i});


$from   ||= "$user\@$hostname";			# envelope-from
$data   ||= 'To: %T\nFrom: %F\nSubject: test\n\nThis is a test mailing\n.';
						# body (\n translated later)
$helo   ||= $hostname;				# who we claim to be in HELO
$port   ||= 25;					# where's the mail server?
$to     ||  process_interact('t');		# who is the mail to?
$server ||= get_server($to);			# receiving server

$data     = join('', <>) if ($opt{g});

#print "\$from   = $from\n";
#print "\$to     = $to\n";
#print "\$helo   = $helo\n";
#print "\$data   = $data\n";
#print "\$server = $server\n";
#print "\$port   = $port\n";
#exit;

$data =~ s/([^\.])$/$1\n./;
$data =~ s/\\n/\r\n/g;
$data =~ s/%F/$from/g;
$data =~ s/%T/$to/g;
$data =~ s/%D/scalar(localtime(time()))/eg;
#print "after parsing, \$data looks like this:\n#\n$data\n#\n";
#exit;
sendmail($from, $to, $helo, $data, $server, $port);

exit;

sub sendmail {
  my($from) = shift;	# envelope-from
  my($to)   = shift;	# envelope-to
  my($helo) = shift;	# who am I?
  my($data) = shift;	# body of message (content after DATA command)
  my($host) = shift;	# receiving host
  my($port) = shift;	# where's the remote smtp process live?

  my($timeout) = 10;
  my($s) = IO::Socket::INET->new(
		PeerAddr => $host,
		PeerPort => $port,
		Proto    => 'tcp',
		Timeout  => $timeout,
           );
  my($buffer) = '';
  my($send) = '';
  $@ = '';
  $| = 1;

  print "=== Trying $host:$port...\n";
  die "Can't connect to $host:$port ($@)\n" if (!$s);
  print "=== Connected to $host.\n";

  # read the server's 220 banner
  $buffer = transact($s, '', '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^220 / || exit;

  # send HELO - expand to ehlo here later
  $send = $opt{q} eq 'connect' ? 'QUIT' : "HELO $helo";
  print " -> $send\n";
  $buffer = transact($s, $send, '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^250 / || exit;

  # send MAIL
  $send = $opt{q} eq 'helo' ? 'QUIT' : "MAIL FROM:<$from>";
  print " -> $send\n";
  $buffer = transact($s, $send, '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^250 / || exit;

  # send RCPT
  $send = $opt{q} eq 'mail' ? 'QUIT' : "RCPT TO:<$to>";
  print " -> $send\n";
  $buffer = transact($s, $send, '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^250 / || exit;

  # send DATA
  $send = $opt{q} eq 'rcpt' ? 'QUIT' : "DATA";
  print " -> $send\n";
  $buffer = transact($s, $send, '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^354 / || exit;

  # send the actual data
  $send = $data;
  $data =~ s/\n/\n -> /msg;
  print " -> $data\n";
  $buffer = transact($s, $send, '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^250 / || exit;

  # send QUIT
  $send = "QUIT";
  print " -> $send\n";
  $buffer = transact($s, $send, '', $timeout);
  print "<-  $buffer\n";
  $buffer =~ /^221 / || exit;

  print "=== Connection closed by foreign host.\n";
}

sub transact {
  my $s    = shift;       # This is my IO::Socket object
  my $send = shift;       # This is the string to send
  my $buff = shift;       # we will store and manipulate the return value here.
  my $alrm = shift || 60; # transaction timeout

  eval {
    local $SIG{'ALRM'} = sub {
      $buff = "Timeout ($alrm secs) waiting for server response";
      die;
    };
    print $s $send, "\n" if ($send); # $send being null means we want to read
    alarm($alrm);
    if ($buff) {
      $buff = '';
    } else {
      $buff = <$s>;
      $buff =~ s/[\r\n]//msg;
    }
  };
  return($buff);
}

sub process_file {
  my($file) = shift;
  
  if (! -e "$file") {
    print STDERR "File $file does not exist, exiting.\n";
    exit(10);
  } elsif (! -f "$file") {
    print STDERR "File $file is not a file, exiting.\n";
    exit(11);
  } elsif (!open(I, "<$file")) {
    print STDERR "Couldn't open $file: $!\n";
    exit(12);
  }

  my($count) = 0;
  while (<I>) {
    chomp;
    $count++;
    next if (/^#?\s*$/); # skip blank lines and those that start w/ '#'
    my($key,$value) = split(/\s+/, $_, 2);
    $key = uc($key);
    if (!$key) {
      print STDERR "Error on line $count: no key found\n";
    } elsif (!$value) {
      print STDERR "Error on line $count: no value found for key $key...\n";
    } elsif ($key eq 'FROM') {
      $from = $value;
    } elsif ($key eq 'TO') {
      $to = $value;
    } elsif ($key eq 'HELO') {
      $helo = $value;
    } elsif ($key eq 'DATA') {
      $data = $value;
    } elsif ($key eq 'SERVER') {
      $server = $value;
    } elsif ($key eq 'PORT') {
      $port = $value;
    } else {
      print STDERR "Error on line $count: unrecognized key $key...\n";
    }
  }
  close(I);
  return;
}

sub process_interact {
  my($args) = shift;
  $args = uc($args);
  my(@args) = split('', $args);

  foreach my $arg (@args) {
    if ($arg eq 'P') {
      $port = interact("Port: ", '^\d+$');
    } elsif ($arg eq 'S') {
      $server = interact("Server: ", '^[a-zA-Z0-9\-\.]+$');
    } elsif ($arg eq 'H') {
      $helo = interact("Helo: ", '^[a-zA-Z0-9\-\.]+$');
    } elsif ($arg eq 'F') {
      $from = interact("From: ", '^\S+$');
    } elsif ($arg eq 'T') {
      $to = interact("To: ", '^\S+$');
    } elsif ($arg eq 'D' && !$opt{g}) {
      if ($opt{m}) {
        $data = "Subject: " . interact("Subject: ", 'SKIP') . "\n\n";
        do {
          $data .= interact('', 'SKIP') . "\n";
        } while ($data !~ /\n\.\n$/ms);
        $data =~ s/\n\.\n$//ms;
      } else {
        $data = interact("Data: ", '^.*$');
      }
    } else {
      print "Unknown option $arg, ignoring...\n";
    }
  }
}

sub interact {
  my($prompt) = shift;
  my($regexp) = shift;
  my($continue) = shift;
  my($response) = '';

  do {
    print "$prompt";
    chomp($response = <>);
  } while ($regexp ne 'SKIP' && $response !~ /$regexp/);

  return($response);
}

sub get_hostname {
  # from hostname(1) on ce-01 (redhat linux 7.1):
  #	Technically: The FQDN is the name gethostbyname(2) returns
  #	for the host name returned  by  gethostname(2).   The  DNS
  #	domain name is the part after the first dot.
  #my($host) = WCS::Util::gethostname();
  #print STDERR "\$host = $host\n";
  #my($fqdn) = gethostbyname($host);
  #print STDERR "\$fqdn = $fqdn\n";
  return((gethostbyname(WCS::Util::gethostname()))[0]);
}

sub get_server {
  my $addr   = shift;
  my $pref   = -1;
  my $server = "localhost";
  my $res    = new Net::DNS::Resolver;

  return($server) if ($addr !~ /\@/);

  $addr =~ s/^.*\@([^\@]*)$/$1/;
  return($server) if (!$addr);

  my @mx = mx($res, $addr);
  foreach my $rr (@mx) {
    if ($rr->preference < $pref || $pref == -1) {
      $pref   = $rr->preference;
      $server = $rr->exchange;
    }
  }
  return($server);
}
