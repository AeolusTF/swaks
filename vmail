#!/usr/bin/perl

use strict; # *gasp*!  A program by jetmore that uses strict?!?!

use IO::Socket qw();
use Sys::Hostname;
use Getopt::Long;

my($from,$to,$helo,$data,$server,$port,$a_type,$a_user,$a_pass) = (undef);
my($fconf)    = {}; # this will hold config info from -l fileif specified
my($user)     = getpwuid($<);
my($hostname) = get_hostname();

GetOptions(
  'l=s'  => \$O::option_file,
  'f:s'  => \$O::mail_from,
  't:s'  => \$O::mail_to,
  'h:s'  => \$O::mail_helo,
  's:s'  => \$O::mail_server,
  'p:i'  => \$O::mail_port,
  'd:s'  => \$O::mail_data,
  'g'    => \$O::data_on_stdin,
  'm'    => \$O::emulate_mail,
  'q=s'  => \$O::quit_after,
  'n'    => \$O::supress_data,
  'a:s'  => \$O::auth,          # force auth, exit if not supported
  'au:s' => \$O::auth_user,     # user for auth
  'ap:s' => \$O::auth_pass,     # pass for auth
  'ao'   => \$O::auth_optional, # make auth optional (ignore auth failure)
) || exit(1);
# l - specify location of a file containing a (l)ist of data to be used
# f - specify the (f)rom address
# t - specify the (t)o address
# h - who do I claim to be in the (h)elo transaction?
# s - what (s)erver do I send this mail to?
# p - what (p)ort do I connect to?
# d - what is the (d)ata section of the email?
# g - (g)et data on STDIN
# m - emulate basic "Mail -v" functionality
# q - send quit after (valid options are 'helo', 'mail', 'rcpt', and 'connect')
# n - do (n)ot print all the data portion

# normalize the auth options a bit
$O::auth = 'ANY' if ((defined($O::auth_user) || defined($O::auth_pass) ||
                      defined($O::auth_optional)) && !$O::auth);
$O::auth = 'ANY' if (defined($O::auth) && !$O::auth);

$O::quit_after = lc($O::quit_after) if ($O::quit_after);

if ($O::emulate_mail) {
  if (!defined($O::mail_to)) {
    $to = shift;
  }
  $O::mail_data = ''; # define it here so we get it on stdin later
}

# load the $fconf hash if user has specified a -l file
process_file($O::option_file, $fconf) if ($O::option_file);

#if (defined($O::mail_to)) {
#  $to = $O::mail_to ||  interact("To: ", '^\S+$');
#} elsif
$to     = $O::mail_to     || interact("To: ", '^\S+$')
                                      if (defined($O::mail_to));
$from   = $O::mail_from   || interact("From: ", '^\S+$')
                                      if (defined($O::mail_from));
$helo   = $O::mail_helo   || interact("Helo: ", '^[a-zA-Z0-9\-\.]+$')
                                      if (defined($O::mail_helo));
$server = $O::mail_server || interact("Server: ", '^[a-zA-Z0-9\-\.]+$')
                                      if (defined($O::mail_server));
$port   = $O::mail_port   || interact("Port: ", '^\d+$')
                                      if (defined($O::mail_port));
if ($O::auth) {
  # make sure we can support it before we go any farther

  if (!try_load("MIME::Base64")) {
    print STDERR "MIME::Base64 not installed, ";
    if (defined($O::auth_optional)) {
      print STDERR "skipping AUTH attempts...\n";
      $a_type = ''; # So we won't attempt it later
    } else {
      print STDERR "exiting...\n";
      exit(10);
    }
  } else {
    # populate the username info
    if (defined($O::auth_user)) {
      $a_user = $O::auth_user;
    } else {
      $a_user = $fconf->{USER}
    }
    $a_user ||= interact("Username: ", 'SKIP');

    # populate the password info
    if (defined($O::auth_pass)) {
      $a_pass = $O::auth_pass;
    } else {
      $a_pass = $fconf->{PASS};
    }
    $a_pass ||= interact("Password: ", 'SKIP');

    $a_type = $O::auth
  }
}

if (defined($O::mail_data) && !defined($O::data_on_stdin)) {
  if (defined($O::emulate_mail)) {
    $data = "Subject: " . interact("Subject: ", 'SKIP') . "\n\n";
    do {
      $data .= interact('', 'SKIP') . "\n";
    } while ($data !~ /\n\.\n$/ms);
    $data =~ s/\n\.\n$//ms;
  } else {
    $data = $O::mail_data || interact("Data: ", '^.*$');
  }
}

# By the time we get here, if the user didn't provide info on command line
# or tell us to prompt for it, we see if it was specified in the -l file,
# and finally use the default value
$from   ||= $fconf->{FROM} || "$user\@$hostname"; # envelope-from
$data   ||= $fconf->{DATA}
        ||  'To: %T\nFrom: %F\nSubject: test\n\nThis is a test mailing\n.';
                                                  # body (\n translated later)
$helo   ||= $fconf->{HELO} || $hostname;          # who we claim to be in HELO
$port   ||= $fconf->{PORT} || 25;                 # where's the mail server?
$to     ||= $fconf->{TO}   || interact("To: ", '^\S+$');
                                                  # who is the mail to?
$server ||= $fconf->{SERVER} || get_server($to);  # receiving server

# The -g option trumps all other methods of getting the data
$data     = join('', <STDIN>) if ($O::data_on_stdin);

#print "\$from   = $from\n";
#print "\$to     = $to\n";
#print "\$helo   = $helo\n";
#print "\$data   = $data\n";
#print "\$server = $server\n";
#print "\$port   = $port\n";
#print "\$a_type = $a_type\n";
#print "\$a_user = $a_user\n";
#print "\$a_pass = $a_pass\n";
#exit;

$data =~ s/([^\.])$/$1\n./;
$data =~ s/\\n/\r\n/g;
$data =~ s/%F/$from/g;
$data =~ s/%T/$to/g;
$data =~ s/%D/scalar(localtime(time()))/eg;
#print "after parsing, \$data looks like this:\n#\n$data\n#\n";
#exit;
sendmail($from, $to, $helo, $data, $server, $port, $a_user, $a_pass, $a_type);

exit;

sub sendmail {
  my $from    = shift;	# envelope-from
  my $to      = shift;	# envelope-to
  my $helo    = shift;	# who am I?
  my $data    = shift;	# body of message (content after DATA command)
  my $host    = shift;	# receiving host
  my $port    = shift;	# where's the remote smtp process live?
  my $a_user  = shift;	# what user to auth with?
  my $a_pass  = shift;	# what pass to auth with
  my $a_type  = shift;	# what kind of auth (this must be set to to attempt)

  my $ehlo    = {};	# If server is esmtp, save advertised features here
  my $timeout = 10;	# timeout for all transactions
  $|          = 1;
  my $s       = IO::Socket::INET->new( PeerAddr => $host, PeerPort => $port,
		                       Proto    => 'tcp', Timeout  => $timeout);

  print_transaction('===', "Trying $host:$port...");
  die "Can't connect to $host:$port ($@)\n" if (!$s);
  print_transaction('===', "Connected to $host.");

  # read the server's 220 banner
  if (!do_smtp_gen($s, '', '220', $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(21);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'connect') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # Send a HELO string
  if (!do_smtp_helo($s, $helo, $timeout, $ehlo)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(22);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'helo') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # handle auth here if user has requested it
  if ($a_type) {
    if (!do_smtp_auth($s, $timeout, $ehlo, $a_type, $a_user, $a_pass)
         && !$O::auth_optional)
    {
      do_smtp_gen($s, 'QUIT', '221', $timeout);
      exit(28);
    }
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'auth') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send MAIL
  if (!do_smtp_gen($s, "MAIL FROM:<$from>", '250', $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(23);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'mail') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send RCPT
  if (!do_smtp_rcpt($s, $to, $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(24);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'rcpt') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send DATA
  if (!do_smtp_gen($s, "DATA", '354', $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(25);
  }

  # send the actual data
  if (!do_smtp_gen($s, "$data", '250', $timeout, undef, $O::supress_data)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(26);
  }

  # send QUIT
  if (!do_smtp_gen($s, "QUIT", '221', $timeout)) {
    exit(27);
  }

  print_transaction('===',  "Connection closed by foreign host.");
}

sub print_transaction {
  my $f = shift;  # transaction flag
  my $m = shift;  # message to print
  my $b = shift;  # be breif in what we print

  if ($b) {
    $m = scalar(split(/\n/ms, $m)) . " lines sent";
  }
  $m =~ s/\n/\n$f /msg;
  print "$f $m\n";
}

sub do_smtp_auth {
  my $s  = shift; # socket
  my $t  = shift; # timeout
  my $e  = shift; # ehlo config hash
  my $at = shift; # auth type
  my $au = shift; # auth user
  my $ap = shift; # auth password

  # I need to handle $a_type here correctly (specific or any), bu just get
  # something to work right now
  #print_transaction('===', "doing auth here");
  #return(1);  # dummy right now

  if (do_smtp_auth_plain($s, $t, $au, $ap)) {
    return(1);
  }

  return(0);
}

sub do_smtp_auth_plain {
  my $s = shift; # socket
  my $t = shift; # timeout
  my $u = shift; # auth user
  my $p = shift; # auth password
  
  my $auth_string = "AUTH PLAIN " . encode_base64("\0$u\0$p");
  chomp($auth_string);
  return(do_smtp_gen($s, $auth_string, '235', $t));
}

sub do_smtp_helo {
  my $s = shift;  # socket
  my $h = shift;  # helo string to use
  my $t = shift;  # timeout
  my $e = shift;  # this is a hashref that will be populated w/ server options
  my $r = '';     # this'll be populated by do_smtp_gen

  if (do_smtp_gen($s, "EHLO $h", '250', $t, \$r)) {
    # $ehlo is designed to hold the advertised options, but I'm not sure how
    # to store them all - for instance, SIZE is a simple key/value pair, but
    # AUTH lends itself more towards a multilevel hash.  What I'm going to do
    # is come here and add each key in the way that makes most sense in each
    # case.  I only need auth for now.
    foreach my $l (split(/\n/, $r)) {
      $l =~ s/^....//;
      if ($l =~ /^AUTH(.*)$/) {
        map { $e->{AUTH}{$_} = 1 } (split(' ', $1));
      }
    }
    return(1);
  } elsif (do_smtp_gen($s, "HELO $h", '250', $t)) {
    return(1);
  }

  return(0);
}

sub do_smtp_rcpt {
  my $s = shift;  # socket
  my $m = shift;  # string of comma separated recipients
  my $t = shift;  # timeout
  my $f = 0;      # The number of failures we've experienced

  my @a = split(/,/, $m);
  foreach my $addr (@a) {
    $f++ if (!do_smtp_gen($s, "RCPT TO:<$addr>", '250', $t));
  }

  # if at least one addr succeeded, we can proceed, else we stop here
  return $f == scalar(@a) ? 0 : 1;
}

sub do_smtp_gen {
  my $s = shift;  # socket
  my $m = shift;  # string to send
  my $e = shift;  # String we're expecting to get back
  my $t = shift;  # timeout
  my $p = shift;  # this is a scalar ref, assign the server return string to it
  my $b = shift;  # be brief in the data we send
  my $r = '';  # This'll be the return value from transact()

  print_transaction(' ->', $m, $b) if ($m);
  $r  = transact($s, $m, '', $t);
  $$p = $r;

  if ($r !~ /^$e /m) {
    print_transaction('***', $r);
    return(0);
  } else {
    print_transaction('<- ', $r);
    return(1);
  }
}

sub transact {
  my $s    = shift;       # This is my IO::Socket object
  my $send = shift;       # This is the string to send
  my $buff = shift;       # we will store and manipulate the return value here.
  my $alrm = shift || 60; # transaction timeout

  eval {
    local $SIG{'ALRM'} = sub {
      $buff = "Timeout ($alrm secs) waiting for server response";
      die;
    };
    print $s $send, "\r\n" if ($send); # $send being null means we want to read
    alarm($alrm);
    if ($buff) {
      $buff = '';
    } else {
      # The 'do' allows for multi-line responses
      do {
        $buff .= <$s>;
      } while ($buff !~ /^\d\d\d /m);
      #$buff = <$s>;
      #$buff =~ s/[\r\n]//msg;
      $buff =~ s/\r//msg;
      chomp($buff);
    }
  };
  return($buff);
}

sub process_file {
  my $f = shift;
  my $h = shift;

  if (! -e "$f") {
    print STDERR "File $f does not exist, skipping...\n";
    return;
  } elsif (! -f "$f") {
    print STDERR "File $f is not a file, skipping...\n";
    return;
  } elsif (!open(I, "<$f")) {
    print STDERR "Couldn't open $f, skipping... ($!)\n";
    return;
  }

  while (<I>) {
    chomp;
    next if (/^#?\s*$/); # skip blank lines and those that start w/ '#'
    my($key,$value) = split(' ', $_, 2);
    $h->{uc($key)} = $value;
  }
  return;
}

sub interact {
  my($prompt) = shift;
  my($regexp) = shift;
  my($continue) = shift;
  my($response) = '';

  do {
    print "$prompt";
    chomp($response = <STDIN>);
  } while ($regexp ne 'SKIP' && $response !~ /$regexp/);

  return($response);
}

sub get_hostname {
  # from hostname(1) on ce-01 (redhat linux 7.1):
  #	Technically: The FQDN is the name gethostbyname(2) returns
  #	for the host name returned  by  gethostname(2).   The  DNS
  #	domain name is the part after the first dot.
  return((gethostbyname(hostname()))[0]);
}

sub get_server {
  my $addr   = shift;
  my $pref   = -1;
  my $server = "localhost";
  
  if (!try_load("Net::DNS")) {
    print STDERR "Net::DNS not installed, using $server as mail server\n";
    return($server);
  }
  my $res = new Net::DNS::Resolver;

  return($server) if ($addr !~ /\@/);

  $addr =~ s/^.*\@([^\@]*)$/$1/;
  return($server) if (!$addr);

  my @mx = mx($res, $addr);
  foreach my $rr (@mx) {
    if ($rr->preference < $pref || $pref == -1) {
      $pref   = $rr->preference;
      $server = $rr->exchange;
    }
  }
  return($server);
}

sub try_load {
  my $mod = shift;

  eval("use $mod");

  if ($@) {
    return(0);
  } else {
    return(1);
  }
}
