#!/usr/bin/perl

use strict; # *gasp*!  A program by jetmore that uses strict?!?!

use IO::Socket qw();
use Sys::Hostname;
use Getopt::Long;

my($from,$to,$helo,$data,$server,$port,$a_type,$a_user,$a_pass,
   $lint) = (undef);
my $fconf    = {}; # this will hold config info from -l fileif specified
my $user     = getpwuid($<);
my $hostname = get_hostname();
my %modules  = ();

GetOptions(
  'l=s'  => \$O::option_file,   # (l)ocation of input data
  'f:s'  => \$O::mail_from,     # envelope-(f)rom address
  't:s'  => \$O::mail_to,       # envelope-(t)o address
  'h:s'  => \$O::mail_helo,     # (h)elo string
  's:s'  => \$O::mail_server,   # (s)erver to use
  'p:i'  => \$O::mail_port,     # (p)ort to use
  'd:s'  => \$O::mail_data,     # (d)ata portion ('\n' for newlines)
  'g'    => \$O::data_on_stdin, # (g)et data on stdin 
  'm'    => \$O::emulate_mail,  # emulate (M)ail command
  'q=s'  => \$O::quit_after,    # (q)uit after (connect,helo,mail,rcpt,auth)
  'n'    => \$O::supress_data,  # do (n)ot print data portion
  'a:s'  => \$O::auth,          # force auth, exit if not supported
  'au:s' => \$O::auth_user,     # user for auth
  'ap:s' => \$O::auth_pass,     # pass for auth
  'ahp:s'=> \$O::auth_hidepw,   # hide passwords when possible
  'apt:s'=> \$O::auth_showpt,   # translate base64 strings
  'ao'   => \$O::auth_optional, # make auth optional (ignore auth failure)
  'support' => \$O::get_support,# report capabilties
  'li:s' => \$O::lint,          # local interface to use for connection
  'tls'  => \$O::tls,           # use TLS
  'tlso' => \$O::tls_optional   # use tls if available
) || exit(1);

load_modules({
  'Basic AUTH'    => ['MIME::Base64'],
  'AUTH CRAM-MD5' => ['Digest::MD5'],
  'MX lookups'    => ['Net::DNS'],
  'TLS'           => ['Net::SSLeay'],
}, \%modules);
exit(0) if ($O::get_support); # --support means report capabilities only

# normalize the TLS options
$O::tls_optional = 1 if (defined($O::tls_optional));
$O::tls = 1 if (defined($O::tls) || $O::tls_optional);
my %tls = (); # will hold info for TLS transactions
if ($O::tls) {
  if (!$modules{'Net::SSLeay'}) {
    print STDERR "Net::SSLeay not installed, TLS unavailable, ";
    if ($O::tls_optional) {
      $O::tls = undef; # so we won't try it later
      print STDERR "skipping\n";
    } else {
      print STDERR "exiting...\n";
      exit(10);
    }
  } else {
    # perform a little house cleaning here
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();
    $tls{active} = 0;
    $tls{con} = undef;
    $tls{ssl} = undef;
  }
}

# normalize the auth options a bit
$O::auth_optional = 1 if (defined($O::auth_optional));
$O::auth = uc($O::auth) if ($O::auth);
$O::auth = 'ANY' if ((defined($O::auth_user) || defined($O::auth_pass) ||
                      $O::auth_optional) && !$O::auth);
$O::auth = 'ANY' if (defined($O::auth) && !$O::auth);

$O::quit_after = lc($O::quit_after) if ($O::quit_after);

if ($O::emulate_mail) {
  if (!defined($O::mail_to)) {
    $to = shift;
  }
  $O::mail_data = ''; # define it here so we get it on stdin later
}

# load the $fconf hash if user has specified a -l file
process_file($O::option_file, $fconf) if ($O::option_file);

$to     = $O::mail_to     || interact("To: ", '^\S+$')
                                      if (defined($O::mail_to));
$from   = $O::mail_from   || interact("From: ", '^\S+$')
                                      if (defined($O::mail_from));
$helo   = $O::mail_helo   || interact("Helo: ", '^[a-zA-Z0-9\-\.]+$')
                                      if (defined($O::mail_helo));
$server = $O::mail_server || interact("Server: ", '^[a-zA-Z0-9\-\.]+$')
                                      if (defined($O::mail_server));
$port   = $O::mail_port   || interact("Port: ", '^\d+$')
                                      if (defined($O::mail_port));
$lint   = $O::lint        || interact("Interface: ", '^[\-\da-zA-Z\.]+')
                                      if (defined($O::lint));
if ($O::auth) {
  # make sure we can support it before we go any farther

  if (!$modules{"MIME::Base64"}) {
    print STDERR "MIME::Base64 not installed, ";
    if ($O::auth_optional) {
      print STDERR "skipping AUTH attempts...\n";
      $a_type = ''; # So we won't attempt it later
    } else {
      print STDERR "exiting...\n";
      exit(10);
    }
  } elsif (!$modules{"Digest::MD5"} && $O::auth =~ /^cram(-md5)?$/i) {
    print STDERR "Digest::MD5 not installed, ";
    if ($O::auth_optional) {
      print STDERR "skipping AUTH attempts...\n";
      $a_type = ''; # So we won't attempt it later
    } else {
      print STDERR "exiting...\n";
      exit(10);
    }
  } else {
    # populate the username info
    if (defined($O::auth_user)) {
      $a_user = $O::auth_user;
    } else {
      $a_user = $fconf->{USER}
    }
    $a_user ||= interact("Username: ", 'SKIP');
    # kludge to allow null users on command line
    $a_user = '' if ($a_user eq 'NULLNULL');

    # populate the password info
    if (defined($O::auth_pass)) {
      $a_pass = $O::auth_pass;
    } else {
      $a_pass = $fconf->{PASS};
    }
    $a_pass ||= interact("Password: ", 'SKIP');
    # kludge to allow null passwords on command line
    $a_pass = '' if ($a_pass eq 'NULLNULL');

    $a_type = $O::auth;
    $O::auth_showpt = 1 if (defined($O::auth_showpt));
    $O::auth_hidepw = 1 if (defined($O::auth_hidepw));
  }
}

if (defined($O::mail_data) && !defined($O::data_on_stdin)) {
  if (defined($O::emulate_mail)) {
    $data = "Subject: " . interact("Subject: ", 'SKIP') . "\n\n";
    do {
      $data .= interact('', 'SKIP') . "\n";
    } while ($data !~ /\n\.\n$/ms);
    $data =~ s/\n\.\n$//ms;
  } else {
    $data = $O::mail_data || interact("Data: ", '^.*$');
  }
}

# By the time we get here, if the user didn't provide info on command line
# or tell us to prompt for it, we see if it was specified in the -l file,
# and finally use the default value
$from   ||= $fconf->{FROM}   || "$user\@$hostname"; # envelope-from
$from     = '' if ($from eq 'NULLNULL');
$data   ||= $fconf->{DATA}
        ||  'To: %T\nFrom: %F\nSubject: test\n\nThis is a test mailing\n';
                                                  # body (\n translated later)
$helo   ||= $fconf->{HELO}   || $hostname;        # who we claim to be in HELO
$port   ||= $fconf->{PORT}   || 25;               # where's the mail server?
$to     ||= $fconf->{TO}     || interact("To: ", '^\S+$');
                                                  # who is the mail to?
$server ||= $fconf->{SERVER} || get_server($to);  # receiving server
$lint   ||= $fconf->{INTERFACE} || '0.0.0.0';     # local interface

# The -g option trumps all other methods of getting the data
$data     = join('', <STDIN>) if ($O::data_on_stdin);

#print "\$from   = $from\n";
#print "\$to     = $to\n";
#print "\$helo   = $helo\n";
#print "\$data   = $data\n";
#print "\$server = $server\n";
#print "\$port   = $port\n";
#print "\$a_type = $a_type\n";
#print "\$a_user = $a_user\n";
#print "\$a_pass = $a_pass\n";
#print "\$lint   = $lint\n";
#exit;

$data .= "\n.";
$data =~ s/\\n/\r\n/g;
$data =~ s/%F/$from/g;
$data =~ s/%T/$to/g;
$data =~ s/%D/scalar(localtime(time()))/eg;
#print "after parsing, \$data looks like this:\n#\n$data\n#\n";
#exit;
sendmail($from, $to, $helo, $data, $server, $port, $a_user, $a_pass, $a_type,
         $lint);

exit;

sub sendmail {
  my $from    = shift;	# envelope-from
  my $to      = shift;	# envelope-to
  my $helo    = shift;	# who am I?
  my $data    = shift;	# body of message (content after DATA command)
  my $host    = shift;	# receiving host
  my $port    = shift;	# where's the remote smtp process live?
  my $a_user  = shift;	# what user to auth with?
  my $a_pass  = shift;	# what pass to auth with
  my $a_type  = shift;	# what kind of auth (this must be set to to attempt)
  my $lint    = shift;	# what local interface to use

  my $ehlo    = {};	# If server is esmtp, save advertised features here
  my $timeout = 100;	# timeout for all transactions
  $|          = 1;
  my $s       = IO::Socket::INET->new( PeerAddr  => $host, PeerPort => $port,
		                       Proto     => 'tcp', Timeout  => $timeout,
                                       LocalAddr => $lint);

  print_transaction('===', "Trying $host:$port...");
  if ($@) {
    print_transaction('***',"Error connecting $lint to $host:$port:\n\t$@");
    exit(2);
  }
  print_transaction('===', "Connected to $host.");

  # read the server's 220 banner
  if (!do_smtp_gen($s, undef, '220', $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(21);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'connect') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # Send a HELO string
  if (!do_smtp_helo($s, $helo, $timeout, $ehlo)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(22);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'helo') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # insert STARTTLS here
  # (does user want it, is it available, did it work, was it required, 
  #  does user want to quit afterwords)

  # handle TLS here if user has requested it
  if ($O::tls) {
    if (!$ehlo->{STARTTLS}) {
      print_transaction('===', "STARTTLS not supported");
      exit(31) if (!$O::tls_optional);
    } elsif (!do_smtp_gen($s, "STARTTLS", '220', $timeout)) {
      print_transaction('===', "STARTTLS unsuccessful");
      if (!$O::tls_optional) {
        do_smtp_gen($s, 'QUIT', '221', $timeout);
        exit(29);
      }
    } elsif (!start_tls($s, \%tls)) {
      print_transaction('===', "TLS startup failed");
      if (!$O::tls_optional) {
        do_smtp_gen($s, 'QUIT', '221', $timeout);
        exit(30);
      }
    } else {
      print_transaction('===', "TLS started w/ cipher $tls{cipher}");
      # don't I need another helo here?
    }
  }

  # handle auth here if user has requested it
  if ($a_type) {
    if (!do_smtp_auth($s, $timeout, $ehlo, $a_type, $a_user, $a_pass)
         && !$O::auth_optional)
    {
      do_smtp_gen($s, 'QUIT', '221', $timeout);
      exit(28);
    }
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'auth') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send MAIL
  if (!do_smtp_gen($s, "MAIL FROM:<$from>", '250', $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(23);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'mail') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send RCPT
  if (!do_smtp_rcpt($s, $to, $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(24);
  }

  # QUIT here if the user has asked us to do so
  if ($O::quit_after eq 'rcpt') {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send DATA
  if (!do_smtp_gen($s, "DATA", '354', $timeout)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(25);
  }

  # send the actual data
  if (!do_smtp_gen($s, "$data", '250', $timeout, undef, $O::supress_data)) {
    do_smtp_gen($s, 'QUIT', '221', $timeout);
    exit(26);
  }

  # send QUIT
  if (!do_smtp_gen($s, "QUIT", '221', $timeout)) {
    exit(27);
  }

  print_transaction('===',  "Connection closed by foreign host.");
}

sub start_tls {
  my $s = shift;
  my $t = shift;

  $t->{con} = Net::SSLeay::CTX_new() || return(0);
  Net::SSLeay::CTX_set_options($t->{con}, &Net::SSLeay::OP_ALL); # error check
  $t->{ssl} = Net::SSLeay::new($t->{con}) || return(0);
  Net::SSLeay::set_fd($t->{ssl}, fileno($s)); # error check?
  $t->{res} = Net::SSLeay::connect($t->{ssl}); # error check
  $t->{cipher} = Net::SSLeay::get_cipher($t->{ssl});
  $t->{active} = 1;

  return(1);
}

sub print_transaction {
  my $f = shift;  # transaction flag
  my $m = shift;  # message to print
  my $b = shift;  # be brief in what we print

  if ($b) {
    $m = scalar(split(/\n/ms, $m)) . " lines sent";
  }
  $m =~ s/\n/\n$f /msg;
  print "$f $m\n";
}

sub do_smtp_auth {
  my $s  = shift; # socket
  my $t  = shift; # timeout
  my $e  = shift; # ehlo config hash
  my $at = shift; # auth type
  my $au = shift; # auth user
  my $ap = shift; # auth password

  # the auth_optional stuff is handled higher up, so tell the truth about
  # failing here

  if (($at ne 'ANY' && !$e->{AUTH}{$at}) || !$e->{AUTH}) {
    print_transaction('===', "$at authentication not supported");
    return(0);
  }

  if (($at eq 'ANY' || $at eq 'CRAM-MD5') && $e->{AUTH}{'CRAM-MD5'}) {
    if ($modules{"Digest::MD5"}) {
      return(1) if (do_smtp_auth_cram($s, $t, $au, $ap));
    } else {
      # debug?
    }
  }
  if (($at eq 'ANY' || $at eq 'PLAIN') && $e->{AUTH}{PLAIN}) {
    return(1) if (do_smtp_auth_plain($s, $t, $au, $ap));
  }
  if (($at eq 'ANY' || $at eq 'LOGIN') && $e->{AUTH}{LOGIN}) {
    return(1) if (do_smtp_auth_login($s, $t, $au, $ap));
  }

  print_transaction('===', "No authentication type succeeded");
  return(0);
}

sub do_smtp_auth_cram {
  my $s = shift; # socket
  my $t = shift; # timeout
  my $u = shift; # auth user
  my $p = shift; # auth password
  my $r = '';    # will store smtp response
  
  my $auth_string = "AUTH CRAM-MD5";
  do_smtp_gen($s, $auth_string, '334', $t, \$r, '', '',
              $O::auth_showpt ? \&unencode_smtp : '')
      || return(0);

  $r =~ s/^....//; # maybe something a little better here?
  my $d = get_digest($p, $r);
  $auth_string = encode_base64("$u $d", '');

  do_smtp_gen($s, $auth_string, '235', $t, undef, '',
              $O::auth_showpt ? "$u $d" : '') || return(0);
  return(1);
}

sub do_smtp_auth_login {
  my $s = shift; # socket
  my $t = shift; # timeout
  my $u = shift; # auth user
  my $p = shift; # auth password
  my $z = '';
  
  my $auth_string = "AUTH LOGIN";
  do_smtp_gen($s, $auth_string, '334', $t, undef, '', '', 
              $O::auth_showpt ? \&unencode_smtp : '') || return(0);
  $auth_string = encode_base64($u, '');
  $z = $u if ($O::auth_showpt);
  do_smtp_gen($s, $auth_string, '334', $t, undef, '', $z,
              $O::auth_showpt ? \&unencode_smtp : '') || return(0);
  $auth_string = encode_base64($p, '');
  $z = $p if ($O::auth_showpt);
  do_smtp_gen($s, $auth_string, '235', $t, undef, '', $z) || return(0);
  return(1);
}

sub do_smtp_auth_plain {
  my $s = shift; # socket
  my $t = shift; # timeout
  my $u = shift; # auth user
  my $p = shift; # auth password
  
  my $auth_string = "AUTH PLAIN " . encode_base64("\0$u\0$p", '');
  my $z = '';
  if ($O::auth_showpt) {
    $z = "AUTH PLAIN \\0$u\\0$p";
  }
  return(do_smtp_gen($s, $auth_string, '235', $t, undef, '', $z));
}

sub do_smtp_helo {
  my $s = shift;  # socket
  my $h = shift;  # helo string to use
  my $t = shift;  # timeout
  my $e = shift;  # this is a hashref that will be populated w/ server options
  my $r = '';     # this'll be populated by do_smtp_gen

  if (do_smtp_gen($s, "EHLO $h", '250', $t, \$r)) {
    # $ehlo is designed to hold the advertised options, but I'm not sure how
    # to store them all - for instance, SIZE is a simple key/value pair, but
    # AUTH lends itself more towards a multilevel hash.  What I'm going to do
    # is come here and add each key in the way that makes most sense in each
    # case.  I only need auth for now.
    # XXX I don't think I'm handling AUTH=LOGIN right.  I think it just means
    # LOGIN and the = is not important - something to check if it's a problem.
    foreach my $l (split(/\n/, $r)) {
      $l =~ s/^....//;
      if ($l =~ /^AUTH(.*)$/) {
        map { $e->{AUTH}{$_} = 1 } (split(' ', $1));
      } elsif ($l =~ /^STARTTLS$/) {
        $e->{STARTTLS} = 1;
      }
    }
    return(1);
  } elsif (do_smtp_gen($s, "HELO $h", '250', $t)) {
    return(1);
  }

  return(0);
}

sub do_smtp_rcpt {
  my $s = shift;  # socket
  my $m = shift;  # string of comma separated recipients
  my $t = shift;  # timeout
  my $f = 0;      # The number of failures we've experienced

  my @a = split(/,/, $m);
  foreach my $addr (@a) {
    $f++ if (!do_smtp_gen($s, "RCPT TO:<$addr>", '250', $t));
  }

  # if at least one addr succeeded, we can proceed, else we stop here
  return $f == scalar(@a) ? 0 : 1;
}

sub do_smtp_gen {
  my $s = shift; # socket
  my $m = shift; # string to send
  my $e = shift; # String we're expecting to get back
  my $t = shift; # timeout
  my $p = shift; # this is a scalar ref, assign the server return string to it
  my $b = shift; # be brief in the data we send
  my $x = shift; # if this is populated, print this instead of $m
  my $c = shift; # if this is a code ref, call it on the return value b4 print
  my $r = '';    # This'll be the return value from transact()

  print_transaction(' ->', $x ? $x : $m, $b) if (defined($m));
  $r  = transact($s, $m, '', $t);
  $$p = $r;

  $r = &$c($r) if (ref($c) eq 'CODE');
  if ($r !~ /^$e /m) {
    print_transaction('***', $r);
    return(0);
  } else {
    print_transaction('<- ', $r);
    return(1);
  }
}

sub transact {
  my $s    = shift;       # This is my IO::Socket object
  my $send = shift;       # This is the string to send
  my $buff = shift;       # we will store and manipulate the return value here.
  my $alrm = shift || 60; # transaction timeout

  eval {
    local $SIG{'ALRM'} = sub {
      $buff = "Timeout ($alrm secs) waiting for server response";
      die;
    };
    #print $s $send, "\r\n" if (defined($send)); # $send being undef means read
    if (defined($send)) {
      if ($tls{active}) {
        #print STDERR "sending tls\n";
        my $res = Net::SSLeay::write($tls{ssl}, "$send\r\n");
      } else {
        #print STDERR "sending plain\n";
        print $s $send, "\r\n";
      }
    }
    alarm($alrm);
    if ($buff) {
      $buff = '';
    } else {
      # The 'do' allows for multi-line responses
      if ($tls{active}) {
        #print STDERR "reading tls\n";
        $buff = Net::SSLeay::read($tls{ssl});
      } else {
        #print STDERR "reading plain\n";
        do {
          $buff .= <$s>;
        } while ($buff !~ /^\d\d\d /m);
      }
      #do {
      #  $buff .= <$s>;
      #} while ($buff !~ /^\d\d\d /m);
      $buff =~ s/\r//msg;
      chomp($buff);
    }
  };
  return($buff);
}

sub unencode_smtp {
  my $t = shift;

  my @t = split(' ', $t);
  return("$t[0] " . decode_base64($t[1]));
}

sub process_file {
  my $f = shift;
  my $h = shift;

  if (! -e "$f") {
    print STDERR "File $f does not exist, skipping...\n";
    return;
  } elsif (! -f "$f") {
    print STDERR "File $f is not a file, skipping...\n";
    return;
  } elsif (!open(I, "<$f")) {
    print STDERR "Couldn't open $f, skipping... ($!)\n";
    return;
  }

  while (<I>) {
    chomp;
    next if (/^#?\s*$/); # skip blank lines and those that start w/ '#'
    my($key,$value) = split(' ', $_, 2);
    $h->{uc($key)} = $value;
  }
  return;
}

sub interact {
  my($prompt) = shift;
  my($regexp) = shift;
  my($continue) = shift;
  my($response) = '';

  do {
    print "$prompt";
    chomp($response = <STDIN>);
  } while ($regexp ne 'SKIP' && $response !~ /$regexp/);

  return($response);
}

sub get_hostname {
  # from hostname(1) on ce-01 (redhat linux 7.1):
  #	Technically: The FQDN is the name gethostbyname(2) returns
  #	for the host name returned  by  gethostname(2).   The  DNS
  #	domain name is the part after the first dot.
  return((gethostbyname(hostname()))[0]);
}

sub get_server {
  my $addr   = shift;
  my $pref   = -1;
  my $server = "localhost";
  
  if (!$modules{"Net::DNS"}) {
    print STDERR "Net::DNS not installed, using $server as mail server\n";
    return($server);
  }
  my $res = new Net::DNS::Resolver;

  return($server) if ($addr !~ /\@/);

  $addr =~ s/^.*\@([^\@]*)$/$1/;
  return($server) if (!$addr);

  my @mx = mx($res, $addr);
  foreach my $rr (@mx) {
    if ($rr->preference < $pref || $pref == -1) {
      $pref   = $rr->preference;
      $server = $rr->exchange;
    }
  }
  return($server);
}

sub try_load {
  my $mod = shift;

  eval("use $mod");

  if ($@) {
    return(0);
  } else {
    return(1);
  }
}

sub get_digest {
  my $secr = shift;
  my $chal = shift;
  my $retr = '';
  my $ipad = chr(0x36);
  my $opad = chr(0x5c);
  my($isec, $osec) = undef;

  if ($chal !~ /^</) {
    chomp($chal = decode_base64($chal));
  }

  if (length($secr) > 64) {
    $secr = Digest::MD5::md5($secr);
  } else {
    $secr .= chr(0) x (64 - length($secr));
  }

  foreach my $char (split(//, $secr)) {
    $isec .= $char ^ $ipad;
    $osec .= $char ^ $opad;
  }

  map { $retr .= sprintf("%02x", ord($_)) }
            split(//,Digest::MD5::md5($osec.Digest::MD5::md5($isec . $chal)));
  return($retr);
}

sub load_modules {
  my $s = shift;
  my $l = shift;

  foreach my $act (keys %$s) {
    my $failed = 0;
    foreach my $m (@{$s->{$act}}) {
      if (try_load($m)) {
        $l->{$m}++;
      } else {
        if (!$failed) {
          print STDERR "$act not available: requires $m" if ($O::get_support);
        } else {
          print STDERR ", $m" if ($O::get_support);
        }
        $failed++;
      }
    }
    if ($failed) {
      print STDERR "\n" if ($O::get_support);
    } else {
      print "$act supported\n" if ($O::get_support);
    }
  }
}

