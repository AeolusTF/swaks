#!/usr/bin/perl

use strict; # *gasp*!  A program by jetmore that uses strict?!?!

use IO::Socket qw();
use Sys::Hostname;
use Getopt::Std;

my($from, $to, $helo, $data, $server, $port) = (undef);
my(%opt) = ();
my($user) = getpwuid($<);
my($hostname) = get_hostname();

if (!getopts('l:f:t:h:s:p:d:i:q:gmn', \%opt)) {
  print STDERR "getopts parsing error\n";
  exit(1);
}
# l - specify location of a file containing a (l)ist of data to be used
# f - specify the (f)rom address
# t - specify the (t)o address
# h - who do I claim to be in the (h)elo transaction?
# s - what (s)erver do I send this mail to?
# p - what (p)ort do I connect to?
# d - what is the (d)ata section of the email?
# i - enter interactive mode
# g - (g)et data on STDIN
# m - emulate basic "Mail -v" functionality
# q - send quit after (valid options are 'helo', 'mail', 'rcpt', and 'connect')
# n - do (n)ot print all the data portion

$opt{q} = lc($opt{q}) if ($opt{q});

if ($opt{m}) {
  if ($opt{i} !~ /t/i && !$opt{t}) {
    $to = shift;
  }
  if ($opt{i} !~ /d/i) {
    $opt{i} .= 'd';
  }
}

process_file($opt{l})     if ($opt{l});
$from   = $opt{f}         if ($opt{f});
$to     = $opt{t}         if ($opt{t});
$helo   = $opt{h}         if ($opt{h});
$server = $opt{s}         if ($opt{s});
$port   = $opt{p}         if ($opt{p});
$data   = $opt{d}         if ($opt{d});
process_interact($opt{i}) if ($opt{i});


$from   ||= "$user\@$hostname";			# envelope-from
$data   ||= 'To: %T\nFrom: %F\nSubject: test\n\nThis is a test mailing\n.';
						# body (\n translated later)
$helo   ||= $hostname;				# who we claim to be in HELO
$port   ||= 25;					# where's the mail server?
$to     ||  process_interact('t');		# who is the mail to?
$server ||= get_server($to);			# receiving server

$data     = join('', <>) if ($opt{g});

#print "\$from   = $from\n";
#print "\$to     = $to\n";
#print "\$helo   = $helo\n";
#print "\$data   = $data\n";
#print "\$server = $server\n";
#print "\$port   = $port\n";
#exit;

$data =~ s/([^\.])$/$1\n./;
$data =~ s/\\n/\r\n/g;
$data =~ s/%F/$from/g;
$data =~ s/%T/$to/g;
$data =~ s/%D/scalar(localtime(time()))/eg;
#print "after parsing, \$data looks like this:\n#\n$data\n#\n";
#exit;
sendmail($from, $to, $helo, $data, $server, $port);

exit;

sub sendmail {
  my($from) = shift;	# envelope-from
  my($to)   = shift;	# envelope-to
  my($helo) = shift;	# who am I?
  my($data) = shift;	# body of message (content after DATA command)
  my($host) = shift;	# receiving host
  my($port) = shift;	# where's the remote smtp process live?

  my($timeout) = 10;
  my($s) = IO::Socket::INET->new(
		PeerAddr => $host,
		PeerPort => $port,
		Proto    => 'tcp',
		Timeout  => $timeout,
           );
  my($buffer) = '';
  my($send) = '';
  $@ = '';
  $| = 1;

  print_transaction('===', "Trying $host:$port...");
  die "Can't connect to $host:$port ($@)\n" if (!$s);
  print_transaction('===', "Connected to $host.");

  # read the server's 220 banner
  if (!do_gen_smtp($s, '', '220', $timeout)) {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(21);
  }

  # QUIT here if the user has asked us to do so
  if ($opt{q} eq 'connect') {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # Send a HELO string
  if (!do_gen_smtp($s, "HELO $helo", '250', $timeout)) {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(22);
  }

  # QUIT here if the user has asked us to do so
  if ($opt{q} eq 'helo') {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send MAIL
  if (!do_gen_smtp($s, "MAIL FROM:<$from>", '250', $timeout)) {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(23);
  }

  # QUIT here if the user has asked us to do so
  if ($opt{q} eq 'mail') {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send RCPT
  if (!do_gen_smtp($s, "RCPT TO:<$to>", '250', $timeout)) {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(24);
  }

  # QUIT here if the user has asked us to do so
  if ($opt{q} eq 'rcpt') {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(0);
  }

  # send DATA
  if (!do_gen_smtp($s, "DATA", '354', $timeout)) {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(25);
  }

  # send the actual data
  if (!do_gen_smtp($s, "$data", '250', $timeout, $opt{n})) {
    do_gen_smtp($s, 'QUIT', '221', $timeout);
    exit(26);
  }

  # send QUIT
  if (!do_gen_smtp($s, "QUIT", '221', $timeout)) {
    exit(27);
  }

  print_transaction('===',  "Connection closed by foreign host.");
}

sub print_transaction {
  my $f = shift;  # transaction flag
  my $m = shift;  # message to print
  my $b = shift;  # be breif in what we print

  if ($b) {
    $m = scalar(split(/\n/ms, $m)) . " lines sent";
  }
  $m =~ s/\n/\n$f /msg;
  print "$f $m\n";
}

sub do_gen_smtp {
  my $s = shift;  # socket
  my $m = shift;  # string to send
  my $e = shift;  # String we're expecting to get back
  my $t = shift;  # timeout
  my $b = shift;  # be brief in the data we send
  my $r = '';     # This'll be the return value from transact()

  print_transaction(' ->', $m, $b) if ($m);
  $r = transact($s, $m, '', $t);

  if ($r !~ /^$e /m) {
    print_transaction('***', $r);
    return(0);
  } else {
    print_transaction('<- ', $r);
    return(1);
  }
}

sub transact {
  my $s    = shift;       # This is my IO::Socket object
  my $send = shift;       # This is the string to send
  my $buff = shift;       # we will store and manipulate the return value here.
  my $alrm = shift || 60; # transaction timeout

  eval {
    local $SIG{'ALRM'} = sub {
      $buff = "Timeout ($alrm secs) waiting for server response";
      die;
    };
    print $s $send, "\n" if ($send); # $send being null means we want to read
    alarm($alrm);
    if ($buff) {
      $buff = '';
    } else {
      # The 'do' allows for multi-line responses
      do {
        $buff .= <$s>;
      } while ($buff !~ /^\d\d\d /m);
      #$buff = <$s>;
      #$buff =~ s/[\r\n]//msg;
      $buff =~ s/\r//msg;
      chomp($buff);
    }
  };
  return($buff);
}

sub process_file {
  my($file) = shift;
  
  if (! -e "$file") {
    print STDERR "File $file does not exist, exiting.\n";
    exit(10);
  } elsif (! -f "$file") {
    print STDERR "File $file is not a file, exiting.\n";
    exit(11);
  } elsif (!open(I, "<$file")) {
    print STDERR "Couldn't open $file: $!\n";
    exit(12);
  }

  my($count) = 0;
  while (<I>) {
    chomp;
    $count++;
    next if (/^#?\s*$/); # skip blank lines and those that start w/ '#'
    my($key,$value) = split(/\s+/, $_, 2);
    $key = uc($key);
    if (!$key) {
      print STDERR "Error on line $count: no key found\n";
    } elsif (!$value) {
      print STDERR "Error on line $count: no value found for key $key...\n";
    } elsif ($key eq 'FROM') {
      $from = $value;
    } elsif ($key eq 'TO') {
      $to = $value;
    } elsif ($key eq 'HELO') {
      $helo = $value;
    } elsif ($key eq 'DATA') {
      $data = $value;
    } elsif ($key eq 'SERVER') {
      $server = $value;
    } elsif ($key eq 'PORT') {
      $port = $value;
    } else {
      print STDERR "Error on line $count: unrecognized key $key...\n";
    }
  }
  close(I);
  return;
}

sub process_interact {
  my($args) = shift;
  $args = uc($args);
  my(@args) = split('', $args);

  foreach my $arg (@args) {
    if ($arg eq 'P') {
      $port = interact("Port: ", '^\d+$');
    } elsif ($arg eq 'S') {
      $server = interact("Server: ", '^[a-zA-Z0-9\-\.]+$');
    } elsif ($arg eq 'H') {
      $helo = interact("Helo: ", '^[a-zA-Z0-9\-\.]+$');
    } elsif ($arg eq 'F') {
      $from = interact("From: ", '^\S+$');
    } elsif ($arg eq 'T') {
      $to = interact("To: ", '^\S+$');
    } elsif ($arg eq 'D' && !$opt{g}) {
      if ($opt{m}) {
        $data = "Subject: " . interact("Subject: ", 'SKIP') . "\n\n";
        do {
          $data .= interact('', 'SKIP') . "\n";
        } while ($data !~ /\n\.\n$/ms);
        $data =~ s/\n\.\n$//ms;
      } else {
        $data = interact("Data: ", '^.*$');
      }
    } else {
      print "Unknown option $arg, ignoring...\n";
    }
  }
}

sub interact {
  my($prompt) = shift;
  my($regexp) = shift;
  my($continue) = shift;
  my($response) = '';

  do {
    print "$prompt";
    chomp($response = <>);
  } while ($regexp ne 'SKIP' && $response !~ /$regexp/);

  return($response);
}

sub get_hostname {
  # from hostname(1) on ce-01 (redhat linux 7.1):
  #	Technically: The FQDN is the name gethostbyname(2) returns
  #	for the host name returned  by  gethostname(2).   The  DNS
  #	domain name is the part after the first dot.
  return((gethostbyname(hostname()))[0]);
}

sub get_server {
  my $addr   = shift;
  my $pref   = -1;
  my $server = "localhost";
  
  if (!try_load("Net::DNS")) {
    print STDERR "Net::DNS not installed, using $server as mail server\n";
    return($server);
  }
  my $res = new Net::DNS::Resolver;

  return($server) if ($addr !~ /\@/);

  $addr =~ s/^.*\@([^\@]*)$/$1/;
  return($server) if (!$addr);

  my @mx = mx($res, $addr);
  foreach my $rr (@mx) {
    if ($rr->preference < $pref || $pref == -1) {
      $pref   = $rr->preference;
      $server = $rr->exchange;
    }
  }
  return($server);
}

sub try_load {
  my $mod = shift;

  eval("use $mod");

  if ($@) {
    return(0);
  } else {
    return(1);
  }
}
